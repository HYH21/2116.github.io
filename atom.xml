<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>2116</title>
  
  <subtitle>2116sub</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/HYH21/hyh21.github.io/"/>
  <updated>2019-07-02T09:42:18.711Z</updated>
  <id>https://github.com/HYH21/hyh21.github.io/</id>
  
  <author>
    <name>HYH</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Test</title>
    <link href="https://github.com/HYH21/hyh21.github.io/2019/07/02/Test/"/>
    <id>https://github.com/HYH21/hyh21.github.io/2019/07/02/Test/</id>
    <published>2019-07-02T09:42:18.000Z</published>
    <updated>2019-07-02T09:42:18.711Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[读书笔记] Android应用性能优化</title>
    <link href="https://github.com/HYH21/hyh21.github.io/2017/03/31/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Android%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://github.com/HYH21/hyh21.github.io/2017/03/31/读书笔记-Android应用性能优化/</id>
    <published>2017-03-31T06:52:40.000Z</published>
    <updated>2017-03-31T06:58:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>一本比较轻量的书，不到一天就可以看完，优化覆盖的面也挺广，会涉及到字节码汇编的一些知识，还有NDK的入门；不足之处里面的API会显得很老，没有收录到最新的优化技巧，提到的点需要自己去深入研究才会更有收获。</p><a id="more"></a><h1 id="读书笔记-Android应用性能优化"><a href="#读书笔记-Android应用性能优化" class="headerlink" title="[读书笔记] Android应用性能优化"></a>[读书笔记] Android应用性能优化</h1><p><img src="http://ohx35e8qs.bkt.clouddn.com/17-3-31/9061655-file_1490942926331_71b4.png" alt></p><h2 id="Java代码优化"><a href="#Java代码优化" class="headerlink" title="Java代码优化"></a>Java代码优化</h2><h3 id="斐波那契数列优化"><a href="#斐波那契数列优化" class="headerlink" title="斐波那契数列优化"></a>斐波那契数列优化</h3><blockquote><p>0,1,1,2,3,5,8…由前面两个数相加</p></blockquote><p>从递归到迭代，从迭代到减少迭代次数，再到缓存以多次运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">computeIterativelyFaster</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">long</span> a, b = <span class="number">1</span>;</span><br><span class="line">    n--;</span><br><span class="line">    a = n &amp; <span class="number">1</span>;</span><br><span class="line">    n /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      a += b;</span><br><span class="line">      b += a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>BigInteger的使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigInteger <span class="title">computeIterativelyFaster</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    BigInteger a, b = BigInteger.ONE;</span><br><span class="line">    n--;</span><br><span class="line">    a = BigInteger.valueOf(n &amp; <span class="number">1</span>);</span><br><span class="line">    n /= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 不断创建新对象，很影响性能</span></span><br><span class="line">      a = a.add(b);</span><br><span class="line">      b = b.add(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (n == <span class="number">0</span>) ? BigIngeter.ZERO : BigInteger.ONE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>斐波那契Q-矩阵公式：</strong><br>$$<br>F_{2n-1} = F_{n}^{2} + F_{n-1}^2\<br>F_{2n} = (2F_{n-1}+F_{n})*F_{n}<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">computeRecursively</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> m = (n / <span class="number">2</span>) + (n &amp; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> fm = computeRecursively(m);</span><br><span class="line">    <span class="keyword">int</span> fm_1 = computeRecursively(m - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> fm * fm + fm_1 * fm_1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="number">2</span> * fm_1 + fm) * fm;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (n == <span class="number">0</span>) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h3><p>字符串的拼接优化</p><p>SQLiteStatement实现只编译一次</p><p>使用ContentValues灵活实现</p><p>使用事务</p><p>FTS全文检索</p><h2 id="高效使用内存"><a href="#高效使用内存" class="headerlink" title="高效使用内存"></a>高效使用内存</h2><p>内存的使用主要涉及的两个因素：</p><ol><li>物理内存大小</li><li>虚拟内存交换能力</li></ol><h3 id="数据类型的长度——字节码层面"><a href="#数据类型的长度——字节码层面" class="headerlink" title="数据类型的长度——字节码层面"></a>数据类型的长度——字节码层面</h3><p>两个64位证书相加的字节码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">448</span>: e0944002 addsr4, r4, r2</span><br><span class="line"><span class="number">44</span>c: e0a55003 adc r5, r5, r3</span><br></pre></td></tr></table></figure><p>两个int型则只需要一条字节码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">16c8: e0810000 addr0, r1, r0</span><br></pre></td></tr></table></figure><h3 id="排序的实现"><a href="#排序的实现" class="headerlink" title="排序的实现"></a>排序的实现</h3><p>Array.sort()对于不同的数据类型是采取不同的算法来进行排序</p><h3 id="内存泄漏-StrictMode检测"><a href="#内存泄漏-StrictMode检测" class="headerlink" title="内存泄漏-StrictMode检测"></a>内存泄漏-StrictMode检测</h3><p>主要有ThreadPolicy和VmPolicy检测，会记录到日志中，需要我们进一步分析日志</p><h2 id="多线程和同步"><a href="#多线程和同步" class="headerlink" title="多线程和同步"></a>多线程和同步</h2><p>使用线程Thread和AsyncTask</p><p>Handler的机制使用</p><p>并发类</p><p>Sychronized和volatile关键字</p><p>使用线程池，并发缓存ConcurrentHashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(proc + <span class="number">2</span>);</span><br><span class="line">executorService.submit();</span><br></pre></td></tr></table></figure><h3 id="一个应用默认启动的线程"><a href="#一个应用默认启动的线程" class="headerlink" title="一个应用默认启动的线程"></a>一个应用默认启动的线程</h3><ul><li>main</li><li>HeapWorker（执行finalize函数和引用对象清理）</li><li>GC（垃圾回收）</li><li>Signal Catcher（捕捉Linux信号进行处理）</li><li>JDWP（Java Debug wire Protocol，调试协议服务）</li><li>Compiler（JIT即时编译）</li><li>Binder Thread #1（Binder通信）</li><li>Binder Thread #2</li></ul><h2 id="图形与UI优化"><a href="#图形与UI优化" class="headerlink" title="图形与UI优化"></a>图形与UI优化</h2><ul><li>嵌套过深：使用&lt;include&gt;、&lt;merge&gt;、&lt;viewstub&gt;；扁平化布局</li></ul><h3 id="工具：hierarchyviewer"><a href="#工具：hierarchyviewer" class="headerlink" title="工具：hierarchyviewer"></a>工具：hierarchyviewer</h3><ul><li>显示当前页面的树结构</li><li>对测量、布局和绘制三个步骤使用的时间进行统计</li></ul><h3 id="工具：layoutopt"><a href="#工具：layoutopt" class="headerlink" title="工具：layoutopt"></a>工具：layoutopt</h3><p>针对单个xml文件给出建议，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The root-level &lt;FrameLayout/&gt; can be replaced with &lt;merge/&gt;</span><br></pre></td></tr></table></figure><h2 id="电池续航"><a href="#电池续航" class="headerlink" title="电池续航"></a>电池续航</h2><p><strong>影响电量的主要功能：</strong></p><ul><li>屏幕：WakeLock</li><li>执行代码：广播，大量运算，定时唤醒</li><li>数据传输：网络，Wifi</li><li>位置服务：网络，GPS</li><li>传感器：加速度计，陀螺仪</li><li>渲染图像：GPU渲染，看不见我们一定要控制停止其渲染</li></ul><h2 id="性能评测和剖析"><a href="#性能评测和剖析" class="headerlink" title="性能评测和剖析"></a>性能评测和剖析</h2><h3 id="时间测量"><a href="#时间测量" class="headerlink" title="时间测量"></a>时间测量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.currentTimeMillis</span><br><span class="line">System.nanoTime<span class="comment">//精度取决于系统的精度</span></span><br><span class="line">Debug.threadCpuTimenanos <span class="comment">//多线程会将每个线程的时间都加在一起</span></span><br><span class="line">SystemClock.currentThreadTimeMillis</span><br><span class="line">SystemClock.elapsedRealtime</span><br><span class="line">SystemClock.uptimeMillis</span><br></pre></td></tr></table></figure><h3 id="方法跟踪"><a href="#方法跟踪" class="headerlink" title="方法跟踪"></a>方法跟踪</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Debug.class</span><br><span class="line">startMethodTracing()</span><br><span class="line">stratMethodTracing(String traceName)<span class="comment">// 记录的文件名</span></span><br><span class="line">startMethodTracing(String traceName, <span class="keyword">int</span> bufferSize)</span><br><span class="line">startMethodTracing(String tarceName, <span class="keyword">int</span> bufferSize, <span class="keyword">int</span> flags)</span><br></pre></td></tr></table></figure><h3 id="TraceView工具"><a href="#TraceView工具" class="headerlink" title="TraceView工具"></a>TraceView工具</h3><p>在SDK的tools目录下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tarceview awesometrace.tarce <span class="comment">// 启动Traceview工具</span></span><br></pre></td></tr></table></figure><p>包含了所有的函数调用，以及调用执行时间和调用次数等信息；</p><p><strong>本地方法调用，利用QEMU模拟器跟踪</strong></p><ul><li>通过-trace选项启动模拟器<code>emulator -trace mytrace -avd myavd</code></li><li>调用Debug.startNativeTracing()和Debug.stopNativeTracing()来进行跟踪，也可以使用F9来启动</li><li>在AVD中会生成QEMU模拟器跟踪文件</li></ul><p><strong>使用tracedmdump命令</strong></p><p>定义在build/envsetup.sh文件中，需要下载Android源码才能使用</p><p>在AVD的目录下运行<code>tracedmdump mytrace</code>来创建traceview可以打开的跟踪文件</p><h2 id="NDK入门和进阶"><a href="#NDK入门和进阶" class="headerlink" title="NDK入门和进阶"></a>NDK入门和进阶</h2><p>NDK是为应用开发本地代码的一套工具</p><h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><p>简单实现一个Java调用C/C++的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Java中声明本地方法，不限定一定是static，也不限定一定是基本类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">recursiveNative</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. JNI粘合层，生成JNI头文件和JNI的C源文件</span></span><br><span class="line">cd /目录;</span><br><span class="line">mkdir jni;</span><br><span class="line">javah -classpath bin -jni -d jni com.apress.proandroid.Fibonacci;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 实现自己的头文件和实现函数，粘合层调用本地方法实现操作，为了方便本地函数的复用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 创建Makefile</span></span><br><span class="line"><span class="comment">// 构建文件</span></span><br><span class="line">Application.mk(可选)</span><br><span class="line">  APP_ABI := armeabi <span class="comment">//针对某个处理器生成一个版本的库</span></span><br><span class="line"><span class="comment">// 针对整个应用的共同变量</span></span><br><span class="line">Android.mk</span><br><span class="line">  LOCAL_PATH := $(call my-dir)<span class="comment">// Android.md的路径</span></span><br><span class="line">  include $(CLEAR_VARS)<span class="comment">// 清除LOCAL_PATH以外的所有LOCAL_XX变量，防出错</span></span><br><span class="line">  LOCAL_MODULE := fibonacci<span class="comment">// 生成库的名称</span></span><br><span class="line">  LOCAL_SRC_FILES := com_apress_proandroid_Fibonacci.c<span class="comment">// JNI的c文件、我们实现的c文件也要添加</span></span><br><span class="line">  include $(BUILD_SHARED_LIBRARY)<span class="comment">// 构件库的规则文件，这里是共享库的规则，还有静态库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 编译本地库，生成so库</span></span><br><span class="line">ndk-build</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 6.加载调用，在适合的时候进行加载本地库，然后java调用Native方法即可，加载失败要自行处理</span></span><br><span class="line">System.loadLibrary(<span class="string">"fibonacci"</span>);</span><br></pre></td></tr></table></figure><p>JNI粘合层，生成JNI的头文件和JNI的C源文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件中的方法声明</span></span><br><span class="line">JNIEXPORT jlong JNICALL</span><br><span class="line">Java_com_apress_proandroid_Fibonacci_recursiveNative(JNIEnv *, jclass, jint);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 源文件中的实现</span></span><br><span class="line">jlong JNICALL</span><br><span class="line">Java_com_apress_proandroid_Fibonacci_recursiveNative(JNIEnv *env, jclass clazz, jint n) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>JNIEnv指针：JNIEnv的对象是JNI环境本身，他可以与虚拟机交互</p><p>jclass/jobject：方法为静态的则是jclass，否则就是jobject类型</p><h3 id="JNI访问Java域、调用方法"><a href="#JNI访问Java域、调用方法" class="headerlink" title="JNI访问Java域、调用方法"></a>JNI访问Java域、调用方法</h3><p>主要通过一个id来进行访问调用，这个id可以通过env来进行获取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取ID</span></span><br><span class="line">jfiledID someIntegerID = (*env)-&gt;GetStaticFieldID(env, clazz, <span class="string">"someInteger"</span>, <span class="string">"I"</span>);</span><br><span class="line">jfiledID helloFromJNIId = (*env)-&gt;GetStaticMethodID(env, clazz, <span class="string">"helloFromJNI"</span>, <span class="string">" ()V"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问调用</span></span><br><span class="line">(*env)-&gt;SetStaticIntField(env, clazz, helloFromJNIId);</span><br><span class="line">(*env)-&gt;ClaaStaticVoidMethod(env, clazz, someIntegerId);</span><br></pre></td></tr></table></figure><h3 id="实现本地Activity"><a href="#实现本地Activity" class="headerlink" title="实现本地Activity"></a>实现本地Activity</h3><ol><li><p>通过实现NativeActivity类</p><p>manifest.xml：hasCode可以关掉了；指定本地库和方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>"<span class="attr">android.app.lib_name</span>"</span></span><br><span class="line"><span class="tag">           <span class="attr">android:value</span>=<span class="string">"myapp"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>"<span class="attr">android.app.func_name</span>"</span></span><br><span class="line"><span class="tag">           <span class="attr">android:value</span>=<span class="string">"ANativeActivity_onCreate"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>功能通过引入相关的头文件实现</p><p>从<code>void android mian(struct android_app* state)</code>开始工作</p></li><li><p>实现纯本地Activity</p><p>通过自己实现生命周期的回调（即是native_app_glue模块实现的功能）</p></li></ol><h3 id="NDK支持编译汇编代码"><a href="#NDK支持编译汇编代码" class="headerlink" title="NDK支持编译汇编代码"></a>NDK支持编译汇编代码</h3><p>很少使用上，太具有系统架构针对性了，需要我们学习指令，x86和ARM汇编的实现都不一样。</p><p>书中有汇编的并行实现功能</p><h3 id="JNI和原生实现的区别（性能）"><a href="#JNI和原生实现的区别（性能）" class="headerlink" title="JNI和原生实现的区别（性能）"></a>JNI和原生实现的区别（性能）</h3><p>原生是编译成Dalvik字节码，JIT优化带来了很大的性能优化</p><p>本地函数是编译成汇编代码，更加紧凑和体积小，但是不一定比原生的快</p><p>需要注意我们再Java和本地空间的过渡时间消耗</p><h3 id="字符串的性能问题"><a href="#字符串的性能问题" class="headerlink" title="字符串的性能问题"></a>字符串的性能问题</h3><p>Java的字符串要提供给本地方法使用的话，必须进行转码</p><p>Java使用16位的Unicode字符来进行编码</p><p>C/C++则大部分使用char *来做字符串用</p><h3 id="C扩展性能优化"><a href="#C扩展性能优化" class="headerlink" title="C扩展性能优化"></a>C扩展性能优化</h3><h4 id="内置函数——build-in"><a href="#内置函数——build-in" class="headerlink" title="内置函数——build-in"></a>内置函数——build-in</h4><p>也被称为内联intrinsics，是有编译器内部进行特别处理的函数，可以在保持代码通用性的同时，充分利用某些平台上特有优化</p><p>直接在调用处用实现替换调用，或者在函数定义前加上inline关键字，小心代码变臃肿</p><p>拆循环，拆成switch/case；效果是不稳定的，不要测试才知道，假如循环体太大，对指令缓存也只是负面影响。</p><h4 id="向量指令"><a href="#向量指令" class="headerlink" title="向量指令"></a>向量指令</h4><p>在CPU支持SIMD指令的情况下，可以大大提高性能；不支持时，则会生成很低性能代码</p><p><code>（vector_size (16)）</code>这是一个4个整数的向量</p><h4 id="预加载内存"><a href="#预加载内存" class="headerlink" title="预加载内存"></a>预加载内存</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* dst, <span class="keyword">const</span> <span class="keyword">int</span>* src;</span><br><span class="line">__builtin_prefetch(dst + <span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//准备写</span></span><br><span class="line">__builtin_prefetch(src + <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//准备读</span></span><br></pre></td></tr></table></figure><p>小心使用，不是必须加载进来是会增加缓存的压力，导致性能降低的</p><h2 id="渲染、RenderScript"><a href="#渲染、RenderScript" class="headerlink" title="渲染、RenderScript"></a>渲染、RenderScript</h2><h3 id="OpenGL-ES"><a href="#OpenGL-ES" class="headerlink" title="OpenGL ES"></a>OpenGL ES</h3><blockquote><p>书中这节属于图形这一章，在这里描述会更好一点</p></blockquote><p>这是一个渲染库</p><p><strong>纹理压缩：</strong></p><blockquote><p>未压缩的256*256的RGBA8888就会占用256KB的内存</p></blockquote><p>ETC1是一个创建纹理的工具（etc1 tool）：舍弃透明度，每个像素使用4位。</p><h3 id="Mipmap"><a href="#Mipmap" class="headerlink" title="Mipmap"></a>Mipmap</h3><p>通过提供多层次细节的纹理，解决在小像素中显示很大的图片，避免浪费内存。</p><p>通过派生出很多种尺寸的图片，所以Mipmap包会比原始图像多用掉33%的存储。</p><h3 id="RenderScript"><a href="#RenderScript" class="headerlink" title="RenderScript"></a>RenderScript</h3><p>针对高性能3D渲染和计算操作的框架</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">脚本文件</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> version(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> rs java_package_name(com.apress.proandrdoi.ch9)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello_world</span><span class="params">()</span></span>&#123;</span><br><span class="line">  rsDebug(<span class="string">"Hello World"</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会自动生成：</p><ul><li>ScriptC_helloworld.java</li><li>helloworld.d</li><li>helloworld.bc</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用</span></span><br><span class="line">RenderScript rs = RenderScript.create(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 创建脚本</span></span><br><span class="line">ScriptC_helloworldScipt helloworldScript = <span class="keyword">new</span> ScriptC_helloworld(rs, getResources(), R.raw.helloworld);</span><br><span class="line"><span class="comment">// 执行，包含反射操作</span></span><br><span class="line">helloworldScript.invoke_hello_world();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以使用RSSurfaceView来绑定渲染</span></span><br><span class="line">使用RenderScriptGL.bindRootScript来进行绑定脚本</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这本书里面使用的代码有点老旧了，一些最新优化方法没有提到，但是他不拘细节的描述，可以在时间很短的情况下看完这本书，这些优化方法还需要自己进一步地去进行深究；这本书的一个好处是对检测的工具也有比较广的介绍，并有提到一些比较冷门的技术点，也是开阔视野的一个不错选择。一句总结：广泛且底层，却不拘细节。</p><p>另外这本书十分执着于字节码和汇编代码上面的影响，也带给了自身不少启发。</p><p>工具的复习：TraceView、hierarchyviewer、layoutopt</p><p>NDK的粗略了解：使用步骤，性能的区别</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一本比较轻量的书，不到一天就可以看完，优化覆盖的面也挺广，会涉及到字节码汇编的一些知识，还有NDK的入门；不足之处里面的API会显得很老，没有收录到最新的优化技巧，提到的点需要自己去深入研究才会更有收获。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://github.com/HYH21/hyh21.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>[元首会晤] https原理及证书验证</title>
    <link href="https://github.com/HYH21/hyh21.github.io/2017/03/27/%E5%85%83%E9%A6%96%E4%BC%9A%E6%99%A4-https%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81/"/>
    <id>https://github.com/HYH21/hyh21.github.io/2017/03/27/元首会晤-https原理及证书验证/</id>
    <published>2017-03-27T12:54:54.000Z</published>
    <updated>2017-03-27T13:16:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>重温梳理了一下计网方面的知识，感觉就像是两国元首如何进行会晤沟通一样，挺有趣，先抽一个安全方面的Https来进行一下首脑之间如何讲悄悄话。</p><a id="more"></a><h2 id="加密算法简介"><a href="#加密算法简介" class="headerlink" title="加密算法简介"></a>加密算法简介</h2><p>正文开始之前，我先来解释简单的解释下对称加密和非对称加密。</p><blockquote><p><strong>对称加密</strong>采用对称密码编码技术，也就是编码和解码采用相同描述字符，即加密和解密使用相同的密钥，实现这种加密技术的算法称对称加密算法。对称加密使用简单，密钥较短，加密和解密过程较快，耗时短，常见的对称加密算法有DES，3DES，lDEA，AES，RC4等。</p></blockquote><blockquote><p><strong>非对称加密</strong>与对称加密不同，其加密算法需要两个密钥：公开密钥（publickey）和私有密钥（private），两者是一对的。如果用公钥加密，只能用私钥才能解密。非对称加密保密性好，但加密和解密花费的时间较长，不适合对大文件加密而只适合对少量的数据加密。常见的非对称加密算法有RSA，ECC，DSA(数字签名)等。</p></blockquote><blockquote><p><strong>Hash算法</strong>是一种单向算法，通过Hash算法可以对目标数据生成一段特定长度、唯一的hash值,但是不能通过这个hash值重新计算出原始的数据，因此也称之为摘要算法，经常被用在不需要数据还原的密码加密以及数据完整性校验上，常用的算法有MD2，MD4，MD5，SHA等。</p></blockquote><h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><p>为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。SSL目前的版本是3.0，被IETF（Internet Engineering Task Force）定义在RFC 6101中，之后IETF对SSL 3.0进行了升级，于是出现了TLS（Transport Layer Security） 1.0，定义在RFC 2246。<strong>实际上我们现在的HTTPS都是用的TLS协议</strong>，但是由于SSL出现的时间比较早，并且依旧被现在浏览器所支持，因此SSL依然是HTTPS的代名词，但无论是TLS还是SSL都是上个世纪的事情，SSL最后一个版本是3.0，今后TLS将会继承SSL优良血统继续为我们进行加密服务。</p><h3 id="验证流程"><a href="#验证流程" class="headerlink" title="验证流程"></a>验证流程</h3><h4 id="简明流程"><a href="#简明流程" class="headerlink" title="简明流程"></a>简明流程</h4><p><img src="http://ohx35e8qs.bkt.clouddn.com/17-3-27/69709947-file_1490619944392_3109.png" alt><br>上面这张图片已经清楚的展示了HTTPS工作的流程。</p><ol><li>[Server]生成一对密钥：公钥和私钥，我们称之为“KeyPub”，“KeyPri”</li><li>[Server]服务端将公钥（KeyPub）发送到客户端</li><li>[Client]生成一个对称密钥（姑且称之为key2），然后用key2加密数据。</li><li>[Client]使用公钥（KeyPub）加密key2.这时，key2是安全的，因为只有服务度有私钥KeyPri</li><li>[Client]发送用key2加密后的信息及用KeyPub加密过的key2到服务端</li><li>[Server]服务端使用KeyPri解密得到加密过的key2，得到真正的key2</li><li>[Server]使用key2解密消息正文。这样，数据就被安全的传输到了服务端。<br>（上教程未说明证书的作用）</li></ol><h4 id="流程（含证书）"><a href="#流程（含证书）" class="headerlink" title="流程（含证书）"></a>流程（含证书）</h4><p><img src="http://ohx35e8qs.bkt.clouddn.com/17-3-27/80510192-file_1490619981812_760a.png" alt><br>注：文中所写的序号与图不对应但流程是对应的</p><ol><li><p>客户端发起一个https的请求，把自身支持的一系列Cipher Suite（密钥算法套件，简称Cipher）发送给服务端</p></li><li><p>服务端，接收到客户端所有的Cipher后与自身支持的对比，如果不支持则连接断开，反之则会从中选出一种加密算法和HASH算法</p><p><strong>以证书的形式</strong>返回给客户端 证书中还包含了 <strong>公钥</strong> 颁证机构 网址 失效日期等等。</p></li><li><p>客户端收到服务端响应后会做以下几件事</p></li></ol><ul><li><p>验证证书的合法性(<strong>如何验证参考下文的数字证书部分</strong>)<br> 颁发证书的机构是否合法与是否过期，证书中包含的网站地址是否与正在访问的地址一致等</p></li><li><p>生成随机密码<br> 如果证书验证通过，或者用户接受了不授信的证书，此时浏览器<strong>会生成一串随机数</strong>，然后用<strong>证书中的公钥</strong>加密。</p></li><li><p>HASH握手信息<br> 用最开始约定好的HASH方式，把握手消息取HASH值，  然后用 <strong>随机数</strong>加密 “<strong>握手消息+握手消息HASH值(签名)</strong>”  并一起发送给服务端<br> 在这里之所以要取握手消息的HASH值，主要是把握手消息做一个签名，用于<strong>验证握手消息在传输过程中没有被篡改过</strong>。</p></li></ul><ol><li><p>服务端拿到客户端传来的密文，用<strong>自己的私钥</strong>来解密握手消息取出<strong>随机数密码</strong>，再用随机数密码 解密 握手消息与HASH值，并与传过来的HASH值做对比确认是否一致。</p><p>然后用随机密码加密一段握手消息(握手消息+握手消息的HASH值 )给客户端</p></li><li><p>客户端用随机数解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的<strong>随机密码并利用对称加密算法</strong>进行加密</p><p>因为这串密钥只有客户端和服务端知道，所以即使中间请求被拦截也是没法解密数据的，以此保证了通信的安全</p></li></ol><h3 id="为何需要如此复杂"><a href="#为何需要如此复杂" class="headerlink" title="为何需要如此复杂"></a>为何需要如此复杂</h3><p>主要是因为非对称加密的性能比对称加密的性能差。可参考如下文章<br><a href="http://blog.csdn.net/dd864140130/article/details/52598107" target="_blank" rel="noopener">http://blog.csdn.net/dd864140130/article/details/52598107</a></p><h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>由Certificate  Authority机构发放。</p><p>我们将自己生成的CSR提交给签名商，他们用中级证书机构的私钥Private Key给我们的签名成证书。而他们的的证书又是通过Root CA颁发的（即Root CA通过它的私钥对中级机构提交的CSR进行了签名）。</p><h3 id="证书组成"><a href="#证书组成" class="headerlink" title="证书组成"></a>证书组成</h3><ol><li><p>证书内容（Certificate）：<br>证书所有人公钥（Subject’s Public Key Info）、<br>签发机构（Issuer）、<br>标识名 (Distinguished Name) 等</p></li><li><p>加密算法（Certificate Signature Algorithm）：<br>包含hash算法和非对称算法两个算法，一般为SHA1和REA</p></li><li><p>数字签名（Certificate Signature Value）：<br><strong>Certificate —&gt; hash1 —签发机构签名—&gt; 数字签名</strong><br>由hash算法对证书内容进行加密得到hash1，再使用<strong>签发此证书机构的私匙</strong>对hash1进行加密得到数字签名。<br>（需要使用机构的公匙才可以进行解密）<br><strong>注意：此处是签发此证书的CA机构的私匙</strong></p></li></ol><h3 id="证书链"><a href="#证书链" class="headerlink" title="证书链"></a>证书链</h3><p>一般现在有 根证书、中间证书、个人证书。事实会存在层数不同的证书。是父子关系。</p><ol><li>根证书<br>签发机构就是本身，windows自带有一部分根证书，这部分证书对于系统来说就是可信的证书。</li></ol><h3 id="证书验证过程"><a href="#证书验证过程" class="headerlink" title="证书验证过程"></a>证书验证过程</h3><p>简单来说，通过hash算法对证书内容取得hash1值，再通过公匙对证书中的数字签名进行解密获得hash2值（为何hash2？参考数字签名组成），若hash1与hash2相符，则认为此证书可信。</p><p>签名验证说明<br><img src="http://ohx35e8qs.bkt.clouddn.com/17-3-27/86806881-file_1490619988194_7dcb.png" alt></p><p><strong>问题出现于hash2的解密公匙来于何处</strong><br>此公匙即此证书的上级证书的证书内容中的所有者公匙。</p><p>在获得父证书并取得其公匙的过程中，需要<strong>验证父证书是否可信</strong>，此时若父证书不是根证书则需要继续获得父证书的上一级证书来验证父证书是否可信。若父证书为<strong>根证书</strong>，则可信，则可用其公匙进行验证。<br>（通过此规则，我们平时<strong>手动添加根证书是不安全</strong>的做法，根证书并的机构并不多，Android已经把将近150个CA根证书（数字证书认证机构认证过的证书）内置在我们手机中。）</p><p>多级验证过程<br><img src="http://ohx35e8qs.bkt.clouddn.com/17-3-27/79149138-file_1490620080666_afed.png" alt></p><p>画图版<br><img src="http://ohx35e8qs.bkt.clouddn.com/17-3-27/2419784-file_1490620036007_6e76.png" alt></p><p>附：证书有多种格式</p><ul><li><p>x.509<br> x.509证书通常用于包含一个公钥</p></li><li><p>PKCS12<br>  PKCS12证书通常用来包含一个私钥。因此，PKCS12需要密码才能打开。</p></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.cnblogs.com/zery/p/5164795.html" target="_blank" rel="noopener">http://www.cnblogs.com/zery/p/5164795.html</a></p><p><a href="http://www.cnblogs.com/hyddd/archive/2009/01/07/1371292.html" target="_blank" rel="noopener">http://www.cnblogs.com/hyddd/archive/2009/01/07/1371292.html</a></p><p><a href="http://lukejin.iteye.com/blog/587200" target="_blank" rel="noopener">http://lukejin.iteye.com/blog/587200</a><br>google，W3c要推进的内容加密协议ontent Security Policy Level 2 is a Candidate Recommendation.，<a href="https://developers.google.com/web/fundamentals/security/csp/" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/security/csp/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重温梳理了一下计网方面的知识，感觉就像是两国元首如何进行会晤沟通一样，挺有趣，先抽一个安全方面的Https来进行一下首脑之间如何讲悄悄话。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://github.com/HYH21/hyh21.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>[Magic Collection &amp; Map] HashMap及其相关类</title>
    <link href="https://github.com/HYH21/hyh21.github.io/2017/03/25/Magic-Collection-Map-HashMap%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E7%B1%BB/"/>
    <id>https://github.com/HYH21/hyh21.github.io/2017/03/25/Magic-Collection-Map-HashMap及其相关类/</id>
    <published>2017-03-25T14:50:14.000Z</published>
    <updated>2017-03-25T15:07:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap、HashTable、TreeMap及其一些并发相关的类小结</p><a id="more"></a><h1 id="HashMap及其相关类"><a href="#HashMap及其相关类" class="headerlink" title="HashMap及其相关类"></a>HashMap及其相关类</h1><p><img src="http://ohx35e8qs.bkt.clouddn.com/17-3-3/31910519-file_1488526439660_d36e.png" alt></p><p>上图不包括concurrentHashMap，它是集成自AbstractMap的。</p><p>以下是四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap<strong>非线程安全</strong>，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 <strong>Collections的synchronizedMap</strong>方法使HashMap具有线程安全的能力，或者使用<strong>ConcurrentHashMap</strong>。</p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>引入分段锁，可并发使用</p><blockquote><p>延伸：ConcurrentLinkedQueue也具有类似功能</p></blockquote><h3 id="HashTable-不建议使用"><a href="#HashTable-不建议使用" class="headerlink" title="HashTable(不建议使用)"></a>HashTable(不建议使用)</h3><p>Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是<strong>线程安全</strong>的，任一时间只有一个线程能写Hashtable，<strong>并发性不如ConcurrentHashMap</strong>，因为ConcurrentHashMap引入了<strong>分段锁</strong>。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p><p>key和value都不允许出现null值。HashTable直接使用对象的hashCode。</p><blockquote><p>延伸，和Vector是遗留类，都具有线程安全性</p></blockquote><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap实现SortedMap接口，能够把它保存的记录<strong>根据键排序</strong>，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，<strong>key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator</strong>，否则会在运行时抛出<strong>java.lang.ClassCastException</strong>类型的异常。</p><h2 id="HashMap原理"><a href="#HashMap原理" class="headerlink" title="HashMap原理"></a>HashMap原理</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>数组+链表+红黑树（JDK1.8新增了红黑树部分）</p><p><img src="http://ohx35e8qs.bkt.clouddn.com/17-3-3/76859766-file_1488528122216_d78c.png" alt></p><p>HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，即图中黑点。</p><p>HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法涉及的主要参数</span></span><br><span class="line"><span class="keyword">int</span> threshold;             <span class="comment">// 所能容纳的key-value对极限 负载因子*大小，默认16*0.75=12</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;    <span class="comment">// 负载因子，默认0.75</span></span><br><span class="line"><span class="keyword">int</span> modCount;  </span><br><span class="line"><span class="keyword">int</span> size;<span class="comment">// 就是HashMap中实际存在的键值对数量</span></span><br><span class="line"><span class="comment">// table的长度length不同于size，数组长度，默认16</span></span><br></pre></td></tr></table></figure><p>默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</p><p>在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考<a href="http://blog.csdn.net/liuqiyao_01/article/details/14475159" target="_blank" rel="noopener">http://blog.csdn.net/liuqiyao_01/article/details/14475159</a>，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。</p><p>这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考<a href="http://blog.csdn.net/v_july_v/article/details/6105630" target="_blank" rel="noopener">http://blog.csdn.net/v_july_v/article/details/6105630</a>。</p><h3 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h3><p>定位的主要hash算法是，三步：<strong>取key的hashCode值、高位运算、取模运算</strong>。</p><blockquote><p>模运算的消耗还是比较大的，在HashMap中是这样做的：调用&amp;来计算该对象应该保存在table数组的哪个索引处。</p><p>这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p><p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，<strong>也能保证考虑到高低Bit都参与到Hash的计算中</strong>，同时不会有太大的开销。</p></blockquote><p><img src="http://ohx35e8qs.bkt.clouddn.com/17-3-3/57677317-file_1488528851723_556d.png" alt></p><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><p><img src="http://ohx35e8qs.bkt.clouddn.com/17-3-3/87750369-file_1488529037481_a975.png" alt></p><h3 id="扩容机制-待进一步学习"><a href="#扩容机制-待进一步学习" class="headerlink" title="扩容机制-待进一步学习"></a>扩容机制-待进一步学习</h3><p>使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p><p>1.7需要重新计算hash值</p><p>1.8不需要重新计算hash值，直接由旧的hash值得出，不会倒置</p><h3 id="线程安全性-待进一步学习"><a href="#线程安全性-待进一步学习" class="headerlink" title="线程安全性-待进一步学习"></a>线程安全性-待进一步学习</h3><p>在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapInfiniteLoop</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,String&gt;(<span class="number">2</span>，<span class="number">0.75f</span>);  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        map.put(<span class="number">5</span>， <span class="string">"C"</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"Thread1"</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                map.put(<span class="number">7</span>, <span class="string">"B"</span>);  </span><br><span class="line">                System.out.println(map);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"Thread2"</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                map.put(<span class="number">3</span>, <span class="string">"A);  </span></span><br><span class="line"><span class="string">                System.out.println(map);  </span></span><br><span class="line"><span class="string">            &#125;;  </span></span><br><span class="line"><span class="string">        &#125;.start();        </span></span><br><span class="line"><span class="string">    &#125;  </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="优化，如何提升性能？"><a href="#优化，如何提升性能？" class="headerlink" title="优化，如何提升性能？"></a>优化，如何提升性能？</h2><ol><li>解决扩容损失：如果知道大致需要的容量，把初始容量设置好以解决扩容损失；<br>比如我现在有1000个数据，需要 1000/0.75 = 1333 个坑位，又 1024 &lt; 1333 &lt; 2048，所以最好使用2048作为初始容量。 </li><li>解决碰撞损失：使用高效的HashCode与loadFactor，这个…由于JDK8的高性能出现，这儿问题也不大了。</li><li>解决数据结构选择的错误：在大型的数据与搜索中考虑使用别的结构比如TreeMap，这个就是知识积累了。一般需要key排序时，建议使用TreeMap，本文暂不讨论；</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</li><li>负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</li><li>HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。</li><li>JDK1.8引入红黑树大程度优化了HashMap的性能。</li><li>还没升级JDK1.8的，现在开始升级吧。HashMap的性能提升仅仅是JDK1.8的冰山一角。</li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://tech.meituan.com/java-hashmap.html" target="_blank" rel="noopener">Java 8系列之重新认识HashMap</a></li><li><a href="http://www.jianshu.com/p/e54047b2b563" target="_blank" rel="noopener">HashMap的实现与优化</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HashMap、HashTable、TreeMap及其一些并发相关的类小结&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://github.com/HYH21/hyh21.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="https://github.com/HYH21/hyh21.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Collection&amp;Map" scheme="https://github.com/HYH21/hyh21.github.io/tags/Collection-Map/"/>
    
  </entry>
  
  <entry>
    <title>[Magic Collection &amp; Map] Java、Android集合类概况、继承关系</title>
    <link href="https://github.com/HYH21/hyh21.github.io/2017/03/22/Magic-Collection-Map-Java%E3%80%81Android%E9%9B%86%E5%90%88%E7%B1%BB%E6%A6%82%E5%86%B5%E3%80%81%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB/"/>
    <id>https://github.com/HYH21/hyh21.github.io/2017/03/22/Magic-Collection-Map-Java、Android集合类概况、继承关系/</id>
    <published>2017-03-22T09:46:08.000Z</published>
    <updated>2017-03-25T14:55:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要使用UML图，介绍Java和Android涉及到的容器类之间的关系，作为一个索引，来进行接下来的一些集合源码的阅读。</p><a id="more"></a><p>[TOC]</p><h1 id="Magic-Collection-amp-Map-Java、Android集合类概况、继承关系"><a href="#Magic-Collection-amp-Map-Java、Android集合类概况、继承关系" class="headerlink" title="[Magic Collection &amp; Map] Java、Android集合类概况、继承关系"></a>[Magic Collection &amp; Map] Java、Android集合类概况、继承关系</h1><p>容器的具体关系主要可以分为：</p><ul><li>Collection<ul><li>List：</li><li>Set：不可重复的一组数据</li><li>Queue、Deque：可以进行队列操作的数据</li></ul></li><li>Map：键值对</li><li>并发类汇总：<ul><li>Blocking、Concurrent、CopyOnWrite</li></ul></li></ul><h2 id="选择集合的考虑"><a href="#选择集合的考虑" class="headerlink" title="选择集合的考虑"></a>选择集合的考虑</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ol><li>数组实现：随机访问时性能最好</li><li>链表实现：在执行插入、删除操作时有很好的性能</li><li>栈和队列：queue可以作为队列，Deque可以作为队列和栈，在只需要队列的情况下应使用queue来限制操作</li></ol><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ol><li>存储不重复的数据时使用Set</li><li>对于普通的插入、删除操作，LinkedHashSet比HashSet要略慢一点，遍历会快</li><li>EnumSet是所有Set实现类中性能最好的，但它只能保存同一个枚举类的枚举值作为集合元素</li></ol><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ol><li>使用HashMap而不是HashTable，HashTable需要同步消耗</li><li>需要排序再使用TreeMap，构建红黑树的方式进行排序</li></ol><h1 id="Collection、Iterator"><a href="#Collection、Iterator" class="headerlink" title="Collection、Iterator"></a><strong>Collection、Iterator</strong></h1><p>Iterator，可以使用<code>foreach</code> 进行遍历，还有迭代器<code>iterator()</code> 方法进行遍历</p><p>Collection就是一个组数据的集合</p><blockquote><p>打不开点击这个链接打开大图 <a href="http://i2.buimg.com/567571/d01721b1ed7c847c.png" target="_blank" rel="noopener">http://i2.buimg.com/567571/d01721b1ed7c847c.png</a></p></blockquote><p><img src="http://i4.buimg.com/567571/b4073e4931744de8.png" alt></p><h2 id="List-1"><a href="#List-1" class="headerlink" title="List"></a><strong>List</strong></h2><p>作为一个线性表接口，可重复，因此可以通过<code>索引</code> 来指定位置的集合元素</p><h3 id="ArrayList、LinkedList"><a href="#ArrayList、LinkedList" class="headerlink" title="ArrayList、LinkedList"></a>ArrayList、LinkedList</h3><ul><li>ArrayList基于数组封装，默认大小是12，每次扩容至原来的1.5倍</li><li>LinkedList继承自AbstractSequentialList，使用链表实现，实现了Queue和Deque，可以用作队列和栈</li></ul><h3 id="Vector、Stack"><a href="#Vector、Stack" class="headerlink" title="Vector、Stack"></a>Vector、Stack</h3><ul><li>Vector与ArrayList几乎一样，古老的版本，支持线程安全</li><li>Starck是Vector 的子类，栈的结构（后进先出）</li></ul><h2 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a><strong>Set</strong></h2><p>实现Collection，不能有重复的数据，使用equals来判断是否相同，使用Map来实现</p><h3 id="HashSet、LinkedHashSet、EnumSet"><a href="#HashSet、LinkedHashSet、EnumSet" class="headerlink" title="HashSet、LinkedHashSet、EnumSet"></a>HashSet、LinkedHashSet、EnumSet</h3><ul><li>使用Hash来决定存储位置，使用equals+HashCode来判断两个对象是否相同</li></ul><ul><li>继承自HashSet，使用链表实现，需要维护元素插入位置，适合遍历；实现了Deque接口，可以作为栈队列来进行使用</li></ul><ul><li>EnumSet提供给枚举类使用</li></ul><h3 id="SortedSet——TreeSet"><a href="#SortedSet——TreeSet" class="headerlink" title="SortedSet——TreeSet"></a>SortedSet——TreeSet</h3><ul><li>TreeSet是SortedSet的实现，保证元素有序</li></ul><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a><strong>Queue</strong></h2><h3 id="ArrayQueue、PriorityQueue"><a href="#ArrayQueue、PriorityQueue" class="headerlink" title="ArrayQueue、PriorityQueue"></a>ArrayQueue、PriorityQueue</h3><p>数组实现的队列和优先级队列</p><h3 id="Deque——ArrayDeque"><a href="#Deque——ArrayDeque" class="headerlink" title="Deque——ArrayDeque"></a>Deque——ArrayDeque</h3><p>数组实现的双端队列，可以用作队列和栈</p><h1 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a><strong>Map</strong></h1><p>保存键值对数据（key-value）</p><p><img src="http://i2.buimg.com/567571/2581a95e6dc36714.png" alt></p><h3 id="HashMap、HashTable、LinkedHashMap"><a href="#HashMap、HashTable、LinkedHashMap" class="headerlink" title="HashMap、HashTable、LinkedHashMap"></a>HashMap、HashTable、LinkedHashMap</h3><ul><li>HashMap用key 的hashCode 值进行hash定位，用equals+hashCode方法判断两个key 相等</li><li>HashTable继承自Dictionary，并实现Map接口，线程安全，古老类</li></ul><ul><li>LinkedHashMap继承自HashMap，按照插入顺序排序，使用双向链表</li></ul><h3 id="SortedMap——TreeMap"><a href="#SortedMap——TreeMap" class="headerlink" title="SortedMap——TreeMap"></a>SortedMap——TreeMap</h3><p>是一个红黑树结构，会进行排序</p><h3 id="WeakHashMap、IdentityHashMap、EnumMap"><a href="#WeakHashMap、IdentityHashMap、EnumMap" class="headerlink" title="WeakHashMap、IdentityHashMap、EnumMap"></a>WeakHashMap、IdentityHashMap、EnumMap</h3><ul><li>WeakHashMap”弱引用”，可能会被垃圾回收</li><li>IdentityHashMap使用“==”来进行判断key是否相等</li></ul><ul><li>EnumMap枚举类实现的Map</li></ul><h1 id="并发类相关"><a href="#并发类相关" class="headerlink" title="并发类相关"></a><strong>并发类相关</strong></h1><p>List相关：</p><p><img src="http://i4.buimg.com/567571/a8dd100a65953002.png" alt></p><p>Set相关：</p><p><img src="http://i2.buimg.com/567571/a0e08cf40d4cb101.png" alt></p><p>Map相关：</p><p><img src="http://i2.buimg.com/567571/aeee6bf5de1b3f64.png" alt></p><h2 id="Concurrent"><a href="#Concurrent" class="headerlink" title="Concurrent"></a>Concurrent</h2><ol><li>ConcurrentHashMap</li><li>ConcurrentSkipListMap</li><li>ConcurrentSkipListSet</li><li>ConcurrentLinkedQueue</li></ol><h2 id="CopyOnWrite"><a href="#CopyOnWrite" class="headerlink" title="CopyOnWrite"></a>CopyOnWrite</h2><ol><li>CopyOnWriteArrayList</li><li>CopyOnWriteArraySet</li></ol><h2 id="Blocking"><a href="#Blocking" class="headerlink" title="Blocking"></a>Blocking</h2><ol><li>LinkedBlockingDeque</li><li>LinkedBlockingQueue</li><li>ArrayBlockingQueue</li><li>PriorityBlockingQueue</li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="http://www.runoob.com/java/java-collections.html" target="_blank" rel="noopener">Java 集合框架</a></li><li><a href="https://github.com/Tikitoo/blog/issues/30">Java 学习之集合类（Collections）</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要使用UML图，介绍Java和Android涉及到的容器类之间的关系，作为一个索引，来进行接下来的一些集合源码的阅读。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://github.com/HYH21/hyh21.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="https://github.com/HYH21/hyh21.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Collection&amp;Map" scheme="https://github.com/HYH21/hyh21.github.io/tags/Collection-Map/"/>
    
  </entry>
  
</feed>
